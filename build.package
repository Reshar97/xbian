##
##      Copyright (C) 2012 - 2014 XBian
##
##  Find us at: http://www.xbian.org http://github.com/xbianonpi/xbian
##
##  This Program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2, or (at your option)
##  any later version.
##
##  This Program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with XBMC; see the file COPYING.  If not, see
##  <http://www.gnu.org/licenses/>.
##
##

config_patch_fuzzy=1000
opt_arch=''
opt_action=''
result=0

if [ -e $XBIANROOT/common.functions ]; then
    . $XBIANROOT/common.functions
else
    echo "Wrong setup. Open folder containing xbianonpi/xbian clone and rerun \"./run.me prepare\""
    exit 500
fi

do_prep()
{
    dir="$1"

    if [ -d hooks.d/pre-configure.d ]; then
        for f in $(ls hooks.d/pre-configure.d); do
#            ( cd "$dir/working"; rexp ../env; QEMU_SET_ENV=QEMU_STACK_SIZE=1048576 do_run $config_build_env sh ../../../hooks.d/pre-configure.d/$f; )
            ( cd "$dir/working"; do_run sh ../../../hooks.d/pre-configure.d/$f; )
        done
    fi

    cd "$dir/working"
    runprepare=0

    if [ -n "$config_source_prepare" ]; then
        if [ -e configure ]; then
            [ "$( find ./ -iname configure.\* -newer configure | grep -c .; )" -gt 0 ] && runprepare=1
        else
            runprepare=1
        fi

#        [ $runprepare -eq 1 ] && ( rexp ../env; do_run $config_build_env $config_source_prepare; )
        [ $runprepare -eq 1 ] && ( do_run $config_source_prepare; )
    fi

    runconfigure=0
    if [ -n "$config_source_configure" ]; then
        if [ -e configure ]; then
            if [ -e Makefile ]; then
                [ "$( find ./ \( -iname Makefile \) ! -newer configure | grep -c .; )" -gt 0 ] && runconfigure=1
            else
                runconfigure=1
            fi
        else
            runconfigure=1
        fi

        [ $runconfigure -eq 1 ] && ( rexp ../env; do_run $config_build_env $config_source_configure; )
    fi
}

do_make()
{
    dir="$1"

    if [ -d hooks.d/pre-build.d ]; then
        for f in $(ls hooks.d/pre-build.d); do
            ( cd "$dir/working"; do_run $config_build_env sh ../../../hooks.d/pre-build.d/$f; )
        done
    fi

    cd "$dir/working"

    if [ -n "$config_build_targets" ]; then
        for t in $config_build_targets; do
            ( rexp ../env; do_run $config_build_env $config_build_make $t; )
        done
    else
        ( rexp ../env; do_run $config_build_env $config_build_make; )
    fi
}

do_patch()
{
    dir=$(basename "$1")
    [ ! -d ./patches ] && return
    cd ./patches

    for p in $({ find -L ./ -maxdepth 1 -iname \*.patch -type f 2>/dev/null; find -L "./$dir" -iname \*.patch -type f 2>/dev/null; } | sort); do
        (
        cd ../build/$dir/working
        echo "checking $p"
        if ! patch -p1 --dry-run -F $config_patch_fuzzy < ../../../patches/$p >/dev/null; then
            continue
        fi
        echo "Patching with $p"
        patch -p1 -F $config_patch_fuzzy < ../../../patches/$p
        echo "-----------------"
        )
    done

    cd ..
    if [ -d extra-files/$dir ]; then
        (
        cd extra-files/$dir
        find ./ -type f -print0 | xargs -0 cp -avr --parents --target-directory="../../$1/working"
        )
    fi
}

do_wipe()
{
    dir="$1"
    do_run rm -fr "$dir/working"
}

do_clean()
{
    dir="$1"
    cd "$dir/working"

    do_run $config_build_env $config_build_make clean
}

do_clone()
{
    dir="$1"

    if [ "$config_source_keep" != yes ]; then
        do_wipe "$dir"
    fi

    cd "$dir"
    if [ ! -d "./working" ]; then
        case "$config_source_type" in
            git)
                config_branch=''
                [ -n "$config_source_branch" ] && export config_branch="-b "
                do_run git clone $config_branch$config_source_branch $config_source_type_extra $config_source_addr working
                ;;
            *)
                ;;
        esac
        cd ./working
    else

    cd ./working
    if [ "$config_source_reset" = yes ]; then
        case "$config_source_type" in
            git)
                do_run git reset --hard
                do_run git clean -df -e '\*.o' -e '\*.P'
                ;;
            *)
                ;;
        esac
    fi

    if [ "$config_source_branch" = yes ]; then
        case "$config_source_type" in
            git)
                do_run git checkout -t -b "$config_source_branch"
                ;;
            *)
                ;;
        esac
    fi

    if [ "$config_source_refresh" = yes ]; then
        case "$config_source_type" in
            git)
                do_run git pull origin $config_source_branch
#                do_run git merge origin/"$config_source_branch"
                ;;
            *)
                ;;
        esac
    fi
    fi

    cd ../../..
    if [ -d hooks.d/post-clone.d ]; then
        for f in $(ls hooks.d/post-clone.d); do
#            ( cd "$dir/working"; rexp ../env; QEMU_SET_ENV=QEMU_STACK_SIZE=1048576 do_run $config_build_env sh ../../../hooks.d/post-clone.d/$f; )
            ( cd "$dir/working"; do_run sh ../../../hooks.d/post-clone.d/$f; )
        done
    fi

}

do_install()
{
    export MAKEFLAGS=-j1

    export INSTALL_MOD_PATH=$(readlink -f ./content)
    export INSTALL_FW_PATH=$(readlink -f ./content)
    export DESTDIR=$(readlink -f ./content)

    dir="$1"
    if [ "$config_deb_contentclean" = yes ]; then 
        find ./content/ -mindepth 1 -maxdepth 1 ! -regex '.*/DEBIAN' -print0 | \
            xargs -0 -L1 rm -fr

    fi

    cd "$dir/working"
    for t in $config_install_targets; do
        ( rexp ../env; do_run $config_build_env $config_build_make $t; )
    done

}

do_deb()
{
    DESTDIR=$(pwd)/build/$config_platform_branch
    (
        cd "$dir/working"
        commit_src=$(git log -n1 --format=oneline | awk '{print $1}')
        echo "commit_src=$commit_src" > $DESTDIR/src_repo_hash_HEAD
    )

    rm -f ./content/DEBIAN/*

    # backcompatibility only, should be removed 
    [ -e ./content-tpl ] && cp -ar ./content-tpl/* ./content

    [ -e build/content-tpl ] && cp -ar build/content-tpl/* ./content
    [ -e build/$config_platform_branch/content-tpl ] && cp -ar build/$config_platform_branch/content-tpl/* ./content

    export MAKEFLAGS=-j1

    if [ -d hooks.d/pre-deb.d ]; then
        for f in $(ls hooks.d/pre-deb.d); do
#            ( cd "./content"; do_run $config_build_env sh ../hooks.d/pre-deb.d/$f; )
            ( cd "./content"; do_run sh ../hooks.d/pre-deb.d/$f; )
        done
    fi

    [ -z "$config_distro" ] && config_deb_version="$config_deb_version-$(printf '%x' $(date +%s))"
    sed -i "s%__VERSION__%$config_deb_version%" content/DEBIAN/control
    sed -i "s%__ARCHBRANCH__%$config_platform/$config_branch%" content/DEBIAN/control
    sed -i "s%__PKGNAME__%$config_deb_pkgname%" content/DEBIAN/control
    sed -i "s%__PKGDEPS__%Depends: $config_deb_depends%" content/DEBIAN/control

    if [ -n "$config_deb_ctrlextra" ]; then
        sed -i "s%__CTRLEXTRA__%$config_deb_ctrlextra%" content/DEBIAN/control
        printf "%b\n" "$(cat content/DEBIAN/control)" > content/DEBIAN/control.new
        mv content/DEBIAN/control.new content/DEBIAN/control
    else
        sed -i '/__CTRLEXTRA__/d' content/DEBIAN/control
    fi

    ### git log -n1 --format=oneline | awk '{print $1}'
    ### git ls-remote $config_source_addr master | awk '{print $1}'
    [ -e $DESTDIR/src_repo_hash_HEAD ] && . $DESTDIR/src_repo_hash_HEAD && rm -f $DESTDIR/src_repo_hash_HEAD
    echo "  (at commit src $commit_src, commit xbian repo $( [ -e .git ] && git log -n1 --format=oneline | awk '{print $1}'))" >> content/DEBIAN/control

    do_run $config_build_env 'find ./content -type f \( -executable -o -iname \*.so -o -iname \*.ko -o -iname \*.a \) -print0' | do_run $config_build_env xargs -0 strip --strip-unneeded -p 2>/dev/null
    sync
    sh $XBIANROOT/gen.package
    rm -f "$dir"/*.deb
    mv *.deb "$dir"
}

do_show_help()
{
echo "
Usage summary:

  --arch, -m [platform/buildconfig]     existing configurations as listed by --list

  --action, -a [action]                 action to perform:

   wipe         - will completely remove working directory (including git clone of src repository)
   clean        - will run "make clean" in the working tree
   clone        - will run "git clone". if source is already cloned then reset/pull is part of this action
                  and finer control is allowed through three paramters - look at "patch" description
   patch        - will try to re-apply patches. if source is not reset to HEAD, nothing will be applied
                  (git reset operation is running in "clone" action as it is needed for correct auto
                  git pull. wheter reset is performed is controled by parameters config_source_keep,
                  config_source_reset and config_source_refresh - default values is YES)
   prepare      - will prepare sources for compilation. usually ./autogen.sh or ./bootstrap is started,
                  then ./configure. controlled via parameters config_source_prepare and 
                  config_source_configure
   make         - runs "make". if finishes successfully, package is compiled and ready to be packaged
   install      - will run "make install". this will copy binaries into ./content folder, in final folder
                  structure
   deb          - will build package out of ./content folder. part of this action is also updating the
                  control files (version, commits, etc). binaries will be also stripped and final
                  .deb package will be moved into ./build/platform

  --list, -l                 list all available configured platforms / branches

"
}

# ----------------------

GETOPT=$(getopt \
        --longoptions=action:,list,arch:,config_source_refresh:,help \
        --options=a:m:hlo: \
        -- "$@" ) \
        || exit 128

for dir in $(find build/ -mindepth 1 -maxdepth 1 \( -type d -o -type l \) | grep -vw content-tpl |sort); do

    echo "PROCESSING $(basename $dir)";
    unset $(env | grep config_ | awk -F'=' '{print $1}'); opt_arch=''
    result=0

    [ -e build/config ] && rexp build/config
    [ -e "$dir/config_pkgver" ] && rexp "$dir/config_pkgver"
    [ -e "$dir/config" ] && rexp "$dir/config"

    eval set -- ${GETOPT}

    while [ "$#" -gt '0' ]; do
        case "$1" in
            (-l|--list)
                printf "ConfigName: %16s,   Target: %13s,    Branch: %20s,   URL: %-40s\n" "${dir#*build/}" "$(printf "%s" "$config_build_env" | grep -ow ['armhfjessie'\|'armhfwheezy']\*)" $config_source_branch $config_source_addr
                continue 2
                ;;
            (--action|-a)
                opt_action=$2
                shift 2
                ;;
            (--arch|-m)
                opt_arch=$2
                shift 2
                ;;
            (-o)
                do_run export $2
                shift 2
                ;;
            (--help|-h)
                do_show_help
                exit 0
                ;;
            *)
                shift 1
                ;;
        esac
    done

    [ -n "$opt_arch" -a "$opt_arch" != $(basename "$dir") ] && continue
    [ -z "$opt_arch" ] && opt_arch=$(basename "$dir")

    export config_platform=${opt_arch%%-*}
    export config_platform_branch=$opt_arch
    export config_branch=${opt_arch##*-}
    [ $config_branch = $config_platform ] && export config_branch=$config_source_branch

    case $opt_action in
        wipe)
            ( do_wipe "$dir" )
            ;;
        clean)
            ( do_clean "$dir" )
            ;;
        patch)
            ( do_patch "$dir" )
            ;;
        prepare)
            ( do_prep "$dir" )
            ;;
        make)
            ( do_make "$dir" )
            ;;
        clone)
            ( do_clone "$dir" )
            ;;
        install)
            ( do_install "$dir" )
            ;;
        deb)
            ( do_deb "$dir" )
            ;;
        ''|build)
            ( do_clone "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! git clone problem" || result=0
            ( do_patch "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! patch problem" || result=0
            ( do_prep "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! source prep problem" || result=0
            ( do_make "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! make problem" || result=0
            ( do_install "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! install problem" || result=0
            ( do_deb "$dir"; )
            [ $result -gt 0 ] && do_exit "!!! deb problem" || result=0
            ;;
    esac
done
