##
##      Copyright (C) 2012 - 2014 XBian
##
##  Find us at: http://www.xbian.org http://github.com/xbianonpi/xbian
##
##  This Program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2, or (at your option)
##  any later version.
##
##  This Program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with XBMC; see the file COPYING.  If not, see
##  <http://www.gnu.org/licenses/>.
##
##

config_patch_fuzzy=5
opt_arch=''
opt_action=''
result=0
use_debug=no
use_silent=no

if [ -e $XBIANROOT/common.functions ]; then
    . $XBIANROOT/common.functions
else
    echo "Wrong setup. Open folder containing xbianonpi/xbian clone and rerun \"./run.me prepare\""
    exit 500
fi

do_prep()
{
    dir="$1"

    do_hooks pre-configure.d

    cd "$dir/working"
    [ "$2" = force ] && runprepare=1 || runprepare=0

    if [ -n "$config_source_prepare" ]; then
        if [ -e configure ]; then
            [ "$( find ./ -maxdepth 1 -iname configure.\* -newer configure | grep -c .; )" -gt 0 ] && runprepare=1 || :
        else
            runprepare=1
        fi

#        [ $runprepare -eq 1 ] && ( rexp ../env; do_run $config_build_env $config_source_prepare; )
        [ $runprepare -eq 1 ] && ( do_run $config_source_prepare; ) || :
    fi

    [ "$2" = force ] && runconfigure=1 || runconfigure=0
    if [ -n "$config_source_configure" ]; then
        if [ -e configure ]; then
            if [ -e Makefile ]; then
                [ "$( find ./ -maxdepth 1 -iname Makefile ! -newer configure | grep -c .; )" -gt 0 ] && runconfigure=1 || :
            else
                runconfigure=1
            fi
        else
            runconfigure=1
        fi

        [ $runconfigure -eq 1 ] && ( rexp ../env; do_run $config_build_env $config_source_configure; ) || :
    fi
}

do_make()
{
    dir="$1"

    do_hooks pre-build.d

    cd "$dir/working"

    if [ -n "$config_build_targets" ]; then
        for t in $config_build_targets; do
            ( rexp ../env; do_run $config_build_env $config_build_make $t; )
        done
    else
        ( rexp ../env; do_run $config_build_env $config_build_make; )
    fi
}

do_patch()
{
    dir=$(basename "$1")

    if [ -e build/$dir/working/.force.nopatch -a "$2" = fullrun ]; then
        rm -f build/$dir/working/.force.nopatch
        return 0
    fi
    [ ! -d ./patches ] && return 0
    cd ./patches

    for p in $({ find -L ./ -maxdepth 1 -iname \*.patch -type f 2>/dev/null; find -L "./$dir" -iname \*.patch -type f 2>/dev/null; } | sort); do
        (
        cd ../build/$dir/working
        [ $use_silent = yes ] || echo "checking $p"
        if ! patch -p1 --dry-run -F $config_patch_fuzzy < ../../../patches/$p >/dev/null; then
            echo "! won't patch with $p" >/dev/stderr
            continue
        fi
        [ $use_silent = yes ] || echo "Patching with $p"
        do_run patch -p1 -F $config_patch_fuzzy < ../../../patches/$p
        echo "-----------------"
        )
    done

    cd ..
    if [ -d extra-files/$dir ]; then
        (
        cd extra-files/$dir
        find ./ -type f -print0 | xargs -0 cp -avr --parents --target-directory="../../$1/working" || :

        ### add new files into git tracked files
        case "$config_source_type" in
            git)
                files="$(find ./ -type f -print0 | grep -v '\.config')"
                [ -z "$files" ] || find ./ -type f -print0 | grep -v '\.config'| ( cd ../../$1/working; xargs -0 git add )
                ;;
            *)
                ;;
        esac
        )
    fi
}

do_wipe()
{
    dir="$1"
    do_run rm -r "$dir/working"
}

do_clean()
{
    dir="$1"
    cd "$dir/working"

    do_run $config_build_env $config_build_make clean
}

do_clone()
{
    dir="$1"

    if [ "$config_source_keep" != yes ]; then
        do_wipe "$dir"
    fi

    initialrun=no
    cd "$dir"
    if [ ! -d "./working" ]; then
        initialrun=yes
        case "$config_source_type" in
            git)
                config_branch=''
                [ -n "$config_source_branch" ] && export config_branch="-b "
                do_run git clone $config_branch$config_source_branch $config_source_type_extra $config_source_addr working
                ;;
            tar)
                do_run wget $config_source_addr -O $(basename $config_source_addr)
                mkdir -p working
                tar -zxf $(basename $config_source_addr) -C ./working --strip-components 1
                cd ./working
                cd ..
                ;;
            *)
                ;;
        esac
        cd ./working
    else

    cd ./working
    if [ "$config_source_reset" = yes ]; then
        case "$config_source_type" in
            git)
                do_run git clean -df -e *.o -e *.P -e .force*
                do_run git reset --hard origin/$config_source_branch
                ;;
            tar)
                rm -fr ./*
                ( cd ../; tar -zxf $(basename $config_source_addr) -C ./working --strip-components 1; )
                ;;
            *)
                ;;
        esac
    fi

    if [ "$config_source_branch" = yes ]; then
        case "$config_source_type" in
            git)
                do_run git checkout -t -b "$config_source_branch"
                ;;
            *)
                ;;
        esac
    fi

    if [ "$config_source_refresh" = yes -a $initialrun = no ]; then
        touch .force.nopatch
        case "$config_source_type" in
            git)
                ep=''; cmtnr=''
                ### commit local changes into new tmp branch
                if git status | grep -q 'Changes not staged\|Untracked files'; then
                    echo "Saving local changes to 'local-changes'"
                    if [ -z "$(git branch --list local-changes)" ]; then
                        git add .; sync
                        git checkout -b local-changes
                        git commit --allow-empty-message --no-edit || :
                        cmtnr=$(git log -1 local-changes | grep -m1 .| awk '{print $2}')
                    else
                        echo "Branch local-changes already exists, probably it's merge into \
origin/$config_source_branch didn't succeed. fix the situation and remove local-changes, \
then rerun process."
                        echo "ERROR " && return 99
                    fi
                fi
                echo "Back to $config_source_branch"
                git checkout $config_source_branch

                ### reset main branch and pull changes from upstream
                #grep -qi 'url = git://' -m1 .git/config && ep='--depth=1'
                #git pull $ep origin $config_source_branch 2>&1 || :
                echo "Trying pull from remote..."
                do_run git clean -df -e *.o -e *.P -e .force*
                do_run git reset --hard
                do_run git pull origin $config_source_branch

                ### merge our previous changes from tmp branch
                if [ -n "$cmtnr" ]; then
                    echo "Will merge your changes back..."
                    git fetch --unshallow || : >/dev/null 2>&1
                    git merge --no-edit $cmtnr && git branch -D local-changes || return 99
                fi
                ;;
            *)
                ;;
        esac
    fi
    fi

    do_hooks post-clone.d
}

do_install()
{
#    export MAKEFLAGS=-j1

    do_hooks pre-install.d

    export INSTALL_MOD_PATH=$(readlink -f ./content)
    export INSTALL_FW_PATH=$(readlink -f ./content)
    export DESTDIR=$(readlink -f ./content)

    dir="$1"
    if [ "$config_deb_contentclean" = yes -a -e ./content ]; then 
        find ./content/ -mindepth 1 -maxdepth 1 ! -regex '.*/DEBIAN' -print0 | \
            xargs -0 -L1 rm -r >/dev/null 2>&1|| :
    fi
    mkdir -p ./content

    cd "$dir/working"
    for t in $config_install_targets; do
        ( rexp ../env; do_run $config_build_env $config_build_make $t; )
    done

}

do_deb()
{
    DESTDIR=$(pwd)/build/$config_platform_branch
    [ -d "$dir/working" ] && \
    (
        cd "$dir/working"
        commit_src=$(git log -n1 --format=oneline | awk '{print $1}')
        echo "commit_src=$commit_src" > $DESTDIR/src_repo_hash_HEAD
    )

    rm -f ./content/DEBIAN/*

    # backcompatibility only, should be removed 
    [ -e ./content-tpl ] && cp -ar ./content-tpl/* ./content

    [ -e build/content-tpl ] && cp -ar build/content-tpl/* ./content
    [ -n "$config_platform_branch" ] && \
        [ -e build/$config_platform_branch/content-tpl ] && cp -ar build/$config_platform_branch/content-tpl/* ./content

    export MAKEFLAGS=-j1

    if [ -d hooks.d/pre-deb.d ]; then
        for f in $(ls hooks.d/pre-deb.d); do
            ( cd "./content"; do_run sh ../hooks.d/pre-deb.d/$f; )
        done
    fi

    do_readconfig "$dir"

    [ -z "$config_distro" ] && config_deb_version="$config_deb_version-$(date +%s)"
    sed -i "s%__VERSION__%$config_deb_version%" content/DEBIAN/control
    sed -i "s%__ARCHBRANCH__%$config_platform/$config_branch%" content/DEBIAN/control
    sed -i "s%__PKGNAME__%$config_deb_pkgname%" content/DEBIAN/control
    sed -i "s%__PKGDEPS__%Depends: $config_deb_depends%" content/DEBIAN/control

    if [ -n "$config_deb_ctrlextra" ]; then
        sed -i "s%__CTRLEXTRA__%$config_deb_ctrlextra%" content/DEBIAN/control
        printf "%b\n" "$(cat content/DEBIAN/control)" > content/DEBIAN/control.new
        mv content/DEBIAN/control.new content/DEBIAN/control
    else
        sed -i '/__CTRLEXTRA__/d' content/DEBIAN/control
    fi

    ### git log -n1 --format=oneline | awk '{print $1}'
    ### git ls-remote $config_source_addr -h master | awk '{print $1}'
    [ ! -e $DESTDIR/src_repo_hash_HEAD ] || . $DESTDIR/src_repo_hash_HEAD
    rm -f $DESTDIR/src_repo_hash_HEAD

    [ -n "$commit_src" ] && commit_src="at commit src $commit_src,"
    echo "  ($commit_src commit xbian repo $( [ -e .git ] && git log -n1 --format=oneline | awk '{print $1}'))" >> content/DEBIAN/control

    eval export $config_build_env 2>/dev/null && eval export $config_build_env
    find ./content -type f \( -executable -o -iname \*.so -o -iname \*.ko -o -iname \*.a \) -print0 | eval $config_build_env xargs -0 ${CROSS_COMPILE}strip --strip-unneeded -p 2>/dev/null || :
    sync
    do_run $SHELL $XBIANROOT/gen.package
    rm -f "$dir"/*.deb
    mv *.deb "$dir"
    [ ! -d $(pwd)/build/$config_platform_branch/working ] || touch $(pwd)/build/$config_platform_branch/working/.force.aptonly
}

do_show_help()
{
echo "
Usage summary:

  --arch, -m [platform/buildconfig]     existing configurations as listed by --list

  --action, -a [action]                 action to perform:

   wipe         - will completely remove working directory (including git clone of src repository)
   clean        - will run "make clean" in the working tree
   clone        - will run "git clone". if source is already cloned then reset/pull is part of this action
                  and finer control is allowed through three paramters - look at "patch" description
   patch        - will try to re-apply patches. if source is not reset to HEAD, nothing will be applied
                  (git reset operation is running in "clone" action as it is needed for correct auto
                  git pull. wheter reset is performed is controled by parameters config_source_keep,
                  config_source_reset and config_source_refresh - default values is YES)
   prepare      - will prepare sources for compilation. usually ./autogen.sh or ./bootstrap is started,
                  then ./configure. controlled via parameters config_source_prepare and 
                  config_source_configure
   make         - runs "make". if finishes successfully, package is compiled and ready to be packaged
   install      - will run "make install". this will copy binaries into ./content folder, in final folder
                  structure
   deb          - will build package out of ./content folder. part of this action is also updating the
                  control files (version, commits, etc). binaries will be also stripped and final
                  .deb package will be moved into ./build/platform

  --list, -l    - list all available configured platforms / branches
  --debug, -d   - debug output

"
}

# ----------------------

GETOPT=$(getopt \
        --longoptions=action:,list,arch:,config_source_refresh:,help,debug,silent \
        --options=a:m:hlo:ds \
        -- "$@" ) \
        || exit 128

export XBIANPKGDIR="$(pwd)"
if [ -e $XBIANPKGDIR/build.~lock ]; then
    echo "another process running... or stale lock exists at $XBIANPKGDIR/build.~lock"
    exit 100
fi

for dir in $(find build/ -mindepth 1 -maxdepth 1 \( -type d -o -type l \) | grep -vw content-tpl |sort); do
    export XBIANARCHDIR=$(readlink -f "$dir")

    unset $(env | grep config_ | awk -F'=' '{print $1}'); opt_arch=''
    result=0

    eval set -- ${GETOPT}

    do_readconfig "$dir"

    while [ "$#" -gt '0' ]; do
        case "$1" in
            (-l|--list)
                printf "ConfigName: %s\n\tTarget: %s\n\tBranch: %s\n\t   URL: %s\n\n" "${dir#*build/}" "$(printf "%s" "$config_build_env" | grep -ow ['armhfjessie'\|'armhfwheezy']\*)" $config_source_branch $config_source_addr
                continue 2
                ;;
            (--action|-a)
                opt_action=$2
                shift 2
                ;;
            (--arch|-m)
                opt_arch=$2
                shift 2
                ;;
            (-o)
                do_run export $2
                shift 2
                ;;
            (--help|-h)
                do_show_help
                exit 0
                ;;
            (-d|--debug)
                use_debug=yes
                shift
                ;;
            (-s|--silent)
                use_silent=yes
                shift
                ;;
            *)
                shift 1
                ;;
        esac
    done

    [ "$use_debug" = no ] || set -x
    [ -n "$opt_arch" -a "$opt_arch" != $(basename "$dir") ] && continue

    echo "-------------------------------"
    echo "PROCESSING $(basename $dir)";
    echo "-------------------------------"

    [ -z "$opt_arch" ] && opt_arch=$(basename "$dir")

    export config_platform=${opt_arch%%-*}
    export config_platform_branch=$opt_arch
    export config_branch=${opt_arch##*-}
    [ $config_branch = $config_platform ] && export config_branch=$config_source_branch

    touch $XBIANPKGDIR/build.~lock
    trap 'rm -f $XBIANPKGDIR/build.~lock' EXIT

    case $opt_action in
        wipe)
            ( do_wipe "$dir" )
            ;;
        clean)
            ( do_clean "$dir" )
            ;;
        patch)
            ( do_patch "$dir" )
            ;;
        prepare)
            ( do_prep "$dir" force )
            ;;
        make)
            ( do_make "$dir" )
            ;;
        clone)
            ( do_clone "$dir" )
            ;;
        install)
            ( do_install "$dir" )
            ;;
        deb)
            ( do_deb "$dir" )
            ;;
        ''|build)
            dr=$(pwd)
            for act in do_clone do_patch do_prep do_make do_install do_deb; do
                ( $act "$dir" fullrun )
            done 
            ;;
    esac

    printf "\n-------------------------------\nFINISHED OK\n-------------------------------\n"
    exit 0
done

do_readconfig "$(pwd)/build"
[ $config_source_type = raw ] && do_deb "$(pwd)/build"
